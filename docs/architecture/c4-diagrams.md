# C4 Архитектура

---

## 1. Контекстная диаграмма

![Context diagram](context.png)

---

## 2. Контейнерная диаграмма

![Container diagram](container.png)

## 3. Выбор и обоснование технологий.



---

## 4. Описание интерфейсов и компонентов.
При проектировании системы были использованы современные, хорошо интегрируемые и масштабируемые технологии, каждая из которых решает чёткую функциональную задачу. Ниже приведено подробное обоснование выбора для каждой из них.

### 4.1. Клиентское приложение: Kotlin Compose Multiplatform.

**Почему выбрано:**
Compose Multiplatform является современным декларативным UI-фреймворком, который позволяет разрабатывать приложения сразу для нескольких платформ - Android, Desktop (Windows/Linux/macOS), Web (экспериментально). Такой подход значительно ускоряет разработку и снижает стоимость поддержки.

**Ключевые преимущества:**
- Единая кодовая база для UI, логики и состояния.
- Jetpack Compose-подобная архитектура, что упрощает разработку под Android.
- Высокая скорость разработки благодаря декларативности и композиции.
- Нативная производительность без необходимости использования тяжёлых WebView.
- Поддержка multiplatform библиотек, таких как SQLDelight.

**Почему подходит для проекта:**
- Интерфейс активно использует реактивные состояния чатов, поиск, списки сообщений → Compose идеально подходит.
- Возможность запускать приложение как на Android, так и на Desktop полезна для профессионального анализа снимков.
- Экосистема Kotlin снижает входной порог для всей команды и обеспечивает типобезопасность.

### 4.2. Хранение данных на клиенте: SQLDelight.

**Почему выбрано:**
SQLDelight генерирует типобезопасный Kotlin-код на основе SQL-запросов, что делает работу с локальной базой удобной, предсказуемой и безопасной.

**Ключевые преимущества:**
- Типобезопасные DAO, генерируемые автоматически.
- Кроссплатформенность — работает на Android, iOS, JVM, JS.
- Прямая работа с SQL без ORM-слоя → высокая производительность.
- Лёгкость интеграции с Kotlin coroutines/Flow.

**Роль в проекте:**
- Хранение локальной копии истории чатов.
- Быстрый оффлайн-доступ к перепискам.
- Мгновенный поиск по локальной базе без нагрузки на сервер.

### 4.3. Серверное REST API: Spring Boot WebFlux

**Почему выбрано:**
Spring Boot с WebFlux позволяет создавать высоконагруженные реактивные REST-сервисы с минимальными задержками, что особенно важно для потоковых ответов и работы с файлами.

**Ключевые преимущества:**
- Реактивная модель (non-blocking I/O) → высокая масштабируемость.
- Поддержка Kotlin coroutine-friendly подхода.
- Большая экосистема Spring для безопасности, логирования, валидации.
- Удобная интеграция с MinIO и PostgreSQL.

**Задачи Spring Boot в проекте:**
- Управление пользователями и чатами.
- Координация загрузки изображений.
- Упрощённая маршрутизация запросов между клиентом, MinIO и LLM-сервером.
- Хранение метаданных снимков.
- Обработка поиска и перелинковки сообщений.

### 4.4. Хранение изображений: MinIO

**Почему выбрано:**
MinIO — высокопроизводительное S3-совместимое объектное хранилище, которое идеально подходит для работы с большими файлами (изображениями, PDF и т.д.).

**Ключевые преимущества:**
- S3 API, что позволяет легко интегрировать практически с любым языком.
- Масштабируемость и горизонтальное шардирование.
- Локальное, приватное и безопасное хранение без зависимости от AWS.
- Высокая скорость отдачи объектов.

**Роль MinIO в проекте:**
- Хранение всех загруженных снимков.
- Быстрая выдача и удаление изображений.
- Возможность расширять объёмы хранилища без остановки сервиса.

### 4.5. Основная БД: PostgreSQL

**Почему выбрано:**
PostgreSQL — надёжная, производительная и функциональная реляционная СУБД с богатой поддержкой индексов и расширений. Её выбирают в большинстве серьёзных веб-проектов.

**Ключевые преимущества:**
- Надёжность и ACID-гарантии.
- Полнотекстовый поиск (TSVector) → критично для поиска по чатам.
- Работа с JSONB, что удобно для метаданных.
- Высокая производительность при больших объёмах данных.
- Простое горизонтальное и вертикальное масштабирование.

**Использование в проекте:**
- Хранение всех чатов и сообщений.
- Логирование запросов и историй взаимодействий.
- Хранение ссылок на изображения в MinIO.
- Полнотекстовый поиск по текстам чатов.
- Хранение данных о пользователях и настройках.

### 4.6. Сервер LLM: FastAPI (Python)

**Почему выбрано:**
FastAPI — быстрый Python-фреймворк, идеально подходящий для ML-и AI-микросервисов благодаря простоте интеграции с библиотеками машинного обучения.

В проекте используется для хостинга большого языкового модели, обрабатывающей:
- анализ изображений;
- генерацию описаний;
- диалоги;
- поиск по текстам;
- переформулирование и сводки.

**Ключевые преимущества:**
- Очень высокая производительность (Starlette + Uvicorn).
- Асинхронность, что важно при работе с LLM/тяжёлыми задачами.
- Простое подключение моделей через PyTorch/Transformers/MLC/ggml.
- Удобная генерация документации OpenAPI/Swagger.
- Отлично подходит для микросервисной архитектуры.

**Роль FastAPI в проекте:**
- Реализация обработчика обращений к LLM.
- Поддержка потокового вывода (streaming responses) для чата.
- Предварительная обработка изображений.
- Очереди запросов для балансировки нагрузки.

### 4.7. Общая архитектура: комбинирование технологий

**Почему это сочетание является оптимальным:**
- Kotlin MPP позволяет быстро разрабатывать UI и бизнес-логику под любые устройства.
- Spring Boot обеспечивает стабильный, масштабируемый «центральный» API-сервер.
- MinIO и PostgreSQL дают надёжную и быструю инфраструктуру хранения.
- FastAPI даёт гибкость и высокую производительность для AI-части.
- Все компоненты связаны через чёткие REST/HTTP интерфейсы.
- Архитектура легко масштабируется: каждый блок можно вынести в отдельный контейнер или кластер.
